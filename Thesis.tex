\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\setlength{\parindent}{0in}

\usepackage{amsmath,amsthm,amssymb}
\usepackage{graphicx}
%\usepackage{minted}
%\usepackage[dvipsnames]{xcolor}
\usepackage{enumerate}
\usepackage{multicol}
\usepackage{float}
\usepackage{bm}

\newcommand{\res}{\mathcal{R}} \DeclareMathOperator{\arsinh}{arsinh}
\newcommand{\vi}{\bm{\hat{\imath}}} \newcommand{\vj}{\bm{\hat{\jmath}}} 
\newcommand{\vk}{\bm{\hat{k}}} \newcommand{\grad}{\bm \nabla} 
\newcommand{\divg}[1]{\bm{\nabla} \cdot \bm{#1}} \newcommand{\divgg}{\bm{\nabla} \cdot}
\newcommand{\curl}[1]{\bm{\nabla} \times \bm{#1}} \newcommand{\curll}{\bm{\nabla} \times}
\newcommand{\So}{\hbox{So }} \newcommand{\so}{\hbox{ so }}
\newcommand{\Seethat}{\hbox{See that }} \newcommand{\seethat}{\hbox{ see that }}
\newcommand{\Thus}{\hbox{Thus }} \newcommand{\thus}{\hbox{ thus }}
\newcommand{\For}{\hbox{For }} \newcommand{\for}{\hbox{ for }}
\newcommand{\tIf}{\hbox{If }} \newcommand{\tif}{\hbox{ if }}
\newcommand{\As}{\hbox{As }} \newcommand{\as}{\hbox{ as }}
\newcommand{\with}{\hbox{ with }} \newcommand{\tand}{\hbox{ and }} \newcommand{\Let}{\hbox{Let }}
\newcommand{\del}[2]{\frac{\partial #1}{\partial #2}} \newcommand{\dell}[2]{\frac{\partial^2 #1}{\partial #2^2}}
\newcommand{\dstyle}[1]{$\displaystyle #1$} \newcommand{\vhat}[1]{\bm{\hat{#1}}}
\newcommand{\snote}[1]{ \times 10^{#1}} \newcommand{\deltax}{\delta_x}
\newcommand{\bgath}[1]{\begin{gather*} #1 \end{gather*}}
\newcommand{\bath}[1]{\begin{gather} #1 \end{gather}}
\newcommand{\bgaln}[1]{\begin{align*} #1 \end{align*}}
\newcommand{\baln}[1]{\begin{align} #1 \end{align}}
\newcommand{\batrix}[1]{\begin{bmatrix} #1 \end{bmatrix}}

\renewcommand{\thefootnote}{\fnsymbol{footnote}}
\newcounter{step}
\newcommand{\nextstep}{\stepcounter{step} {\large \textcircled{\footnotesize \thestep}} }

\newcommand{\civ}{\bm{\hat{c}}}
\newcommand{\econ}{\bm{\hat{e}}}
\newcommand{\soc}{\bm{\hat{s}}}

\begin{document}
\pagenumbering{gobble}
\begin{center}
\quad \\
\quad \\
\quad \\
\quad \\
\quad \\
\quad \\
\quad \\
\quad \\
\quad \\
\quad \\
\quad \\
\LARGE Votes that Count: Building a Tool to Facilitate Understanding of how Voting Systems\\ Affect Electoral Outcomes\\ \normalsize
\quad \\
\quad \\
Spencer Diamond\\
\quad \\
Director: Dr. Hessam Sarjougian\\
School of Computing and Augmented Intelligence\\
\quad \\
Second Reader: Dr. Taylor Hines\\
Barrett Honors College\\
\quad \\
\end{center}
\newpage
\tableofcontents
\newpage

\pagenumbering{arabic}
\setcounter{page}{1}
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\section{Introduction}
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\qquad The goal of this thesis project is to develop a prototype for an educational tool that will help users understand how the voting system we use can affect the outcomes of our elections. This tool is developed in Java SE, and consists of a visualized model of elections in various voting systems, along with various fairness measures, and educational and explanatory material. While a completed version of this tool would ideally be fully self-contained and accessible in-browser, the current prototyped version consists of a GitHub repository containing the code, with the educational material and explanations contained within this paper. Ultimately, the goal of this project is to create a tool that will instill a measure of systemic skepticism in the user; to give them cause to question why our systems are built the way they are, and reasons to believe that they could be changed for the better. \\

\qquad A voting system is the method by which votes are cast and counted in an election. While there are countless factors that can have great impacts on elections: voting rights, systemic injustice and bias, money, number and location of polling places, mail-in ballots, pre-voting, campaigning, ID laws, etc., none of those factors will be considered for this project. The purpose of this tool is to show a user, absent all other factors and assuming complete political freedom and equality for all citizens, how the way names get on the ballot, the way votes are cast at the polling station, and the way they are counted to determine a winner can change who that winner is determined to be. \\

\qquad An important question that must be answered before continuing is why any of this matters. Why should people care that different voting systems produce different winners, and what good could come out of switching to a different system? The answers to these questions boil down to what function we want our elections to serve. In the tradition of representative democracy, elections are the mechanism by which the people of a nation imbue a representative with political power, and voting in an election is how citizens express their political will by stating their preference for who that representative should be. The answer to our questions lie in the word 'representative.' A good election functions to produce a winner that is a good representation of the political will of the voters. \\

%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\section{Scope}
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\qquad Owning to the sheer complexity within this topic, it is necessary for this project to have a fairly narrow scope. Firstly, this project is focused on single winner elections only. There are many Examples of these kinds of elections would be a Presidential, Gubernatorial, or single MP election. While there are many multi-winner voting systems, and most of the principles that will be discussed later do translate to these kinds of elections, the specifics are much more complex. Because this tool is meant to serve as an introduction to these concepts, that complexity will be detrimental to building understanding, so these kind of elections are excluded from the project. \\

\qquad Secondly, each election is deterministic. If two separate elections of the same type are run with the exact same initial conditions, the same winner will be determined every time. While actual elections with actual people may be lightly stochastic, with individuals voting according to their changing whims, the percentage difference this is likely to cause would be negligible, so for this project it is assumed that each vote is determined without any randomness. \\

\qquad Below, I will describe a few important aspects of the model that at first glance may appear move the project outside this stated scope, so, for clarity, I will address them here. First, the initial conditions for the model are, by default, mostly randomly generated. It might seem like this would undermine the deterministic nature of the model. However, this randomness happens outside of the model, and only serves as a convenient way of generating the initial conditions. If a user generates one set of random initial conditions and uses them to run two identical elections, they will be returned the same result every time. Second, the process of ``nudging'' voters in between elections \textit{is} stochastic. However, the model only requires that individual elections be fully deterministic. The randomness in the nudging process helps the model to more accurately reproduce expected real world behavior. Lastly, a shrewd reader will notice that the optional primary step that can be added to the model technically is a multi-winner election. However, within the tool this extra step is only ever analyzed as a part of the larger single winner election, so we need not worry about the extra complexity. \\

%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\section{The Model}
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\qquad The actual model used in this tool is based on an extension of a system that some may already be familiar with, often called the ``Political Compass.'' This system is based on the juxtaposition of conflicting political positions. It takes the concepts of `Authoritarianism' and `Libertarianism,' and places them at opposite ends of a coordinate axis. Similarly, it takes the fuzzy concepts of `Left' and `Right,' places them at opposite ends of another coordinate axis. These two axis are arranged perpendicular to each other, effectively allowing a person's political ideals to be represented as a point in 2D Cartesian coordinates. This popular conception of the compass has a few problems. Firstly, the terms Authoritarianism, Libertarianism, Left, and Right are ill-defined and cause a good amount of confusion. For Authoritarianism and Libertarianism, almost all of the confusion can be removed by a simple relabeling. In this model, these terms are replaced with `Hierarchical' and `Individualistic,' and the axis they lie on is called the `Civil Axis.' For Left and Right, the problem stems from the fact that there are two different political concepts described with these terms; either someone's economic ideals or their social ideals can be given these labels, and without specifying which is being talked about, this introduces alot of ambiguity. To remedy this issue, this model extended this system into the third dimension by splitting this axis in two, with a new `Economic Axis' labeled with `Socialism' and `Capitalism,' and the new `Social Axis' retaining the `Left' and `Right' labels. To avoid confusion going forward, I will only use the terms Left and Right in their social sense. \\

\qquad In this model, the basic object is called a Political Entity.\footnotetext{For clarity, model objects are always capitalized. For example, `voter' refers to the colloquial, real world concept of a person who votes, while `Voter' refers to a Voter object in the model} In general, a Political Entity is just something that can have a concrete position in the coordinate system we have constructed. Because we have a 3D Cartesian coordinate system, we can easily represent a Political Entity as a vector with Civil, Social, and Economic components. By representing them as vectors, it is easy to find the relative distance between two Political Entities by finding the magnitude of the difference of the vectors. This relative distance, which I will be calling the `norm' of two Political Entities, is the principle measure for most interactions in the model. Nearly all Political Entities used in a specific simulation will be generated beforehand and fed in as the initial conditions. However, there are many circumstances where the model will need to add a Political Entity to the simulation. In these cases, that added Political Entity is called a `virtual' Political Entity. The term `virtual' may be a bit confusing, so just think of it as the opposite of `actual.' It just means that this object is a fictitious book keeping device. Virtual Political Entities are either removed from the simulation as soon as their function is served, or they can be `persistent,' only being removed at the conclusion of a simulation. Virtual Political Entities are never carried over to a separate simulation. \\

\qquad There are two different kinds of Political Entities: Citizens and Parties. Citizens are Political Entities that directly interact with elections. There are two types: Voters and Candidates. Voters are, predictably, Citizens that vote in elections. For a Voter, their specific placement in the coordinate system represents voting preferences. Candidates are Citizens that can be voted for, and their position represents their platform. The norm between a Voter and Candidate represents that Voter's relative preference for that Candidate, so that the Candidate closest to a Voter would be that Voter's first choice in an election. Voters also have an Approval Radius, and will only consider Candidates within that radius. By comparing the norm of each Voter with each Candidate, we construct a Preference List for each Voter. This Preference List is a list of all the Candidates who's norm with the Voter is less than the Voter's Approval Radius, and the list is ordered by norm with the Voter. This list facilitates the giving of votes to Candidates. It is important to note that Candidates are not Voters, so they \textit{do not} vote in the elections. This is done to reduce the complexity of the code, and the ratio of Voters to Candidates is bounded so that this simplification is very likely to be negligible. In very close races, virtual Voters in the same position as each Candidate can be used to resolve ambiguity. \\

\qquad Parties are also Political Entities, but they do not directly interact with the elections by giving or receiving votes. Instead, Parties perform important electoral functions. Citizens have a Party, and Parties have Candidates. It is important to note that this relationship is not symmetrical; Parties do not have Voters. Voters align with a Party, Candidates \textit{belong} to a Party. Because of this difference, it is possible for an individual Voter to not have a Party, but all Candidates must have one. This relationship also means that all Parties must have at least one Candidate. A Party with no Candidates in removed from the simulation. The main function served by Parties is to determine and distribute funding for Candidates. A Parties funding is determined by the number of aligned Voters as well as the number of votes received by that Party's Candidates. The amount of funding a Party has determines how many Candidates that Party can afford to have. While this is not perfectly analogous to how political funding works in the real world, it provides a suitable approximation; more popular and well funded candidates are able to dominate (or at least continue to participate in) elections while less popular candidates my have to drop out or be stifled due to lack of funds or support. Parties can also serve to restrict Voters' behavior. In certain systems, there may be closed Party primaries, or a Voter may only be allowed to vote for Candidates of their same Party. Additionally, in some systems it may be advantageous for a Voter to only consider Candidates that are popular enough to actually have a chance at winning, and Party funding serves as a good heuristic for that (the situations where this could come into play will be discussed later). \\

\qquad There are two other kinds of object in the model that are not Political Entities: Voting Systems and Fairness Measures. Voting Systems contain the current state of a simulation, and also the rules by which votes will be counted. Once the vote counting is done, the Voting System object also contains the winner of each election cycle. Counter intuitively, a single Voting System object can either represent a single election, as with primary elections, or a full simulation containing many election cycles. Fairness Measures take a Voting System object and uses it to conduct a specific test on the current state of the simulation. Fairness Measures always exist in relation to a specific Voting System object. \\

%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\section{The Tool}
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\qquad The general flow of the program is as follows:\nextstep The user selects the number of Voters, Candidates, and Parties; how these will be generated; the type of Voting System and number of election cycles; the type and frequency of Fairness Measures; whether there will be primary elections and if so what kind; and whether/how Parties will affect voting.\nextstep The Voter List, Candidate List, and Party List are generated.\nextstep A Voting System object of the specified type is created with the Voter, Candidate, and Party lists as instance variables.\nextstep Citizens are assigned Parties and Parties identify their Candidates.\nextstep Parties with no Candidates are removed.\nextstep Each Voter's Preference List is generated.\nextstep Party Funding is determined.\nextstep The voting system is applied, and votes are distributed to Candidates.\nextstep A winner is determined; if the race is too close, tie breaking strategies are used before the winner is chosen.\nextstep Fairness Measures are conducted on the current state of the Voting System.\nextstep The state of the simulation, the winner of the election, and the results of the Fairness Measures are displayed to the user.\nextstep Underfunded Parties remove Candidates they cannot afford, in order of least votes received.\nextstep Candidates with no Party are removed and replaced by Voters in the same position as the former Candidate.\nextstep Voters' satisfaction with current winner is generated, and Voters are nudged according to their satisfaction.\nextstep Steps 5 through 14 are repeated for the number of iterations specified at the start, with Fairness Measures only coming into play at the specified frequency.\nextstep For the last iteration, the simulation stops at step 11. If primary elections are part of the simulation, after step 5 a new Voting System object is created as specified and steps 6 through 9 are done for the primary, then the winners are returned and they replace the current Candidate list for the main Voting System until after step 9. \\

\qquad There are currently four types of Voting System for the user to choose from, although many more could be added in the future. These voting systems were chosen for their simplicity and educational value, each one representing a different voting paradigm. The first is called ``First Past the Post.'' Also called ``Plurality'' or ``Single Choice'' voting, this system is the standard, one person one vote, most votes wins system. In this system each person can only vote for one candidate and the candidate with the most votes is elected. For this model, the first Candidate in each Voter's Preference List is given one vote. This system represents the traditional, single vote paradigm, where the only thing considered is a voters first choice. \\

\qquad The second kind is called ``Instant Runoff Voting.'' Also called ``Alternative Vote'' or ``Single-Member Single Transferable Vote,'' this system is a kind of ranked choice voting. In this system, each person ranks candidates in order of their preference. After votes are counted, if no candidates had more than 50\% of the votes, then the candidate who had the lowest number of votes is dropped, and those votes are then given to the second choice candidate on each ballot. This process is repeated until a candidate has more than 50\% of the votes, at which point the candidate with the most votes wins. For the model, the first Candidate in each Voter's Preference List is given one vote. If no candidate has more than 50\% of the votes, the Candidate with the least votes is determined and that Candidate is removed from the Preference Lists of all Voters. While that Candidate is being removed from the Preference Lists, if they were at the top of the list, one vote is given to the new first entry. This continues until a winner is determined. This system represents a preferential voting paradigm, where the preferences of voters should be taken into account when their first choice does not win. \\

\qquad The third kind is ``Approval Voting.'' In this system, people simply mark down each candidate they would find acceptable as a winner. Each mark counts as one vote, and the candidate with the most votes wins. For the model, every Candidate in each Voter's Preference List is given one vote. This system represents a multi vote paradigm, where voters are allowed to cast more than one vote. \\

\qquad The fourth kind of Voting System is called ``Bucklin Voting.'' The name Bucklin Voting can refer to a variety of systems, however the system implemented here is the most general version. Bucklin Voting also uses a ranked choice ballot, where people rank candidates in order of their preference. The amount of votes needed to win is more than 50\% of the number of ballots cast. If no candidate has enough first choice votes, then second choice votes are added to the first choice, and so on. Further preferences are added until a candidate have enough votes, at which point the candidate with the most votes wins. In the model, the number to beat is one half the number of Voters (rounded up if odd). The first Candidate in each Voter's Preference List is given one vote. If no candidate has more votes than the number to beat, the second Candidate in each Voter's Preference List is given one vote. Successive preference levels are added to the count until a Candidate has enough votes. It is possible that more than one Candidate can end up with more than enough votes at the same time, so the winner is still the Candidate with the most votes. This system represents a highest median paradigm, where the winner of an election should be the candidate with the highest average ranking across all voters. \\

\qquad Like with types of Voting System, four types of Fairness Measure are currently implemented, but more could be added in the future. In the literature, what I am calling a Fairness Measure is also called a ``Voting System Criterion.'' They are tests of a voting system's viability and fairness. Similar to how the voting systems were chosen, these have been selected for their educational and demonstrative value. The first criterion is ``Representation Difference.'' Also called the ``Majority Loser'' criterion, a voting system failed this test if a candidate can be elected without a majority of the votes. For the tool this is implemented by simply returning the percentage of votes received by the winning Candidate to the user. A percentage above 50\% is a success, and a percentage below 50\% is a failure. This Fairness Measure is a test for how well a voting system produces a representative winner. It is worth noting that a perfect winner would have the support of every single one of their constituents, and therefore would receive 100\% of available votes. While this scenario is extremely unlikely, users should keep in mind that the higher the percentage is, the more representative that result will be. \\

\qquad The second kind is called the ``Independence of Alternatives.'' This criterion is a combination of two different voting system criteria, the ``Independence of Clones'' and ``Independence of Irrelevant Alternatives.'' Independence of clones is failed when adding a new, non-winning candidate that is very similar to the winner changes the outcome, and independence of irrelevant alternatives is failed when adding or removing a non-winning candidate that has no chance of winning changes the outcome. In general, the Independence of Alternatives is failed when adding or removing a candidate changes the winner, without the winner being the new candidate. For this model, Independence of Alternatives is tested by running three new elections using the current state of the simulation, one with a virtual Candidate that is a clone of the winner with almost identical position, the second with a virtual Candidate positioned near the Candidate with the lowest number of votes (so as to have no chance at becoming the winner), and the last with the Candidate with the lowest number of votes removed. A failure of this test occurs if any of these new elections determines a different winner than the actual election, and that different winner was not an added virtual Candidate. This Fairness Measure is a test for how well a voting system protects diversity of candidates. \\

\qquad The third Fairness Measure is called the ``Condorcet Test.'' This criterion is satisfied when the winner of an election also wins each pairwise contest. That is, the candidate that wins the actual election should also win in a head-to-head election against every other candidate. This ensures that the candidate with the highest average preference among all voters is the winner. In some cases, there can be a ``rock-paper-scissors'' like relationship between a set of candidates, where there is a cycle of pairwise winners; this is called the Smith set. In this case, in the winner of the election is a candidate in the Smith set, the voting system is still considered to pass this criterion. In the model, this criterion is evaluated by checking each pairwise match up between the winner and all other Candidates using the Voters' Preference Lists. If the winner is ranked lower in a majority of Voters' Preference Lists for any match up, and the Candidate being checked in not in the Smith set, this Fairness Measure has been failed. Otherwise, it is a success. To check for the Smith set, any Candidate that beat the winner in the pairwise contest is also checked with the Condorcet Test. If no Candidates win all pairwise match ups, there is a Smith set. This Fairness Measure ensures that the overall highest rated candidate is the winner. \\

\qquad The fourth Fairness Measure is called ``Later no Help/Harm.'' As the name suggests, this criterion is a combination of the ``Later no Help'' and ``Later no Harm'' criteria. ``Later no Help'' is satisfied when a voter specifying more lower ranked candidates cannot help their first choice win. ``Later no Harm'' is satisfied when a voter specifying more lower ranked candidates cannot cause their first choice to not win. Combined together, these two criteria are satisfied if the winner of an election cannot be changed by a voter specifying there later preferences. It is important to note that this only applies to `later' preferences, so a previously abstaining voter specifying their first choice would not count. For the model, this is tested by increasing the Approval Radius of all Voters with a non-empty Preference List. A failure occurs if this changes the winner of the election. This Fairness Measure tests how well a voting system incentivizes sincere rankings. \\ 

\qquad There is a fifth criterion I would like to mention here that is not implemented as a Fairness Measure. ``Two Party Trend'' happens if a field of many parties devolves into only two parties. This is generally considered to be an indication that a voting system is bad at preserving diversity among candidates. Although not implemented into the program, it is still useful for a user to keep this concept in mind. \\

\qquad In reality, voters are not static, they change their political opinions all the time based on many factors. In order to include this in the model, the position of some Voters is changed slightly in between elections. The Voters are `nudged' to reflect their changing voting preference. This is based on the Voter's `Satisfaction' with the winner of the election, as well as that winner's `Performance.' If they are satisfied with the winner's performance, they will be nudged toward that Candidate, but if they are dissatisfied with the winner's performance, they will be nudged away. Some Voters will be neither satisfied nor dissatisfied, and their position will stay the same. A Voter's Satisfaction with the winner is randomized, but the chances of having a particular satisfaction level is weighted by the winner's position in the Voter's Preference List. A Voter is more likely to have a high Satisfaction if the winner is high in their list, and vise-versa. The winner's Performance is also randomized to a degree. This corresponds to how popular the elected official is while in office. A popular winner that did well as a representative would have a high Performance value, an unpopular and unsuccessful one would have a low Performance value. \\

%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\section{Model Details}
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000

\footnotetext[0]{It is important to note that, out of necessity, one of the political ideals on each axis is treated as the negative side of the axis. This is not done disparagingly and does not correspond to the opinions of anyone involved with this project}
\qquad The specific process by which some of the model's systems work contain many complications that would be beneficial to explore more deeply. A casual user may skip these details, but it can be informative to understand the model's inner workings more deeply. Firstly, details about the coordinate system. Each axis of the coordinate system, Economic, Civil, and Social, ranges from -100 to 100, with a value of 0 corresponding to the center of the axis. This way, the position of a Political Entity can be expressed as a vector $\bm{P} = \civ P_{\hbox{civil}} + \econ P_{\hbox{economic}} + \soc P_{\hbox{social}}$ with its base at the origin; where $\civ$, $\econ$, and $\soc$ are the unit vectors in the positive civil, economic, and social directions, respectively, and $P_{\hbox{civil}}, P_{\hbox{economic}}, \tand P_{\hbox{social}}$ are, respectively, the civil, economic, and social components of $\bm{P}$. For example, a Political Entity that is slightly Individualistic, moderately Capitalist, and extremely far Left socially would look something like $\bm{A} = -12\civ + 59\econ - 97\soc$ and could be represented as the vector shown below. \\

\makebox[\textwidth][c]{
\includegraphics[width=0.3\textwidth]{placeholder01.png}}\\

If we add another Political Entity $\bm{B} = 24\civ - 9\econ - 38\soc$ we can now find the norm between them by first finding the deference vector $\bm{B} - \bm{A} = (24 + 12)\civ + (-9 - 59)\econ + (-38 + 97)\soc = 36\civ - 68\econ + 59\soc$. It is possible to find the magnitude (length) of a vector by finding the square root of the sum of the squares of the components of the vector. So $|\bm{B} - \bm{A}| = \sqrt{36^2 + (-68)^2 + 59^2} = 96.96$. So the norm of $\bm{A} \tand \bm{B}$ is 96.96.\\

\makebox[\textwidth][c]{
\includegraphics[width=0.35\textwidth]{placeholder02.png}}\\


%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\section{Problems}
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000

\qquad Some ambiguity comes from the fact that each axis in the coordinate system has opposing concepts at their ends, so there are two interpretations of what a specific placement on the axis means. Each axis can be thought of as a spectrum from one concept to another, like a sliding scale where someone placed at the origin would have no preference either way on any issue. Alternatively, specific placement can be the average of many different positions, so that someone at the origin could have very strong opinions on most or all issues, but all their positions average out to the center. This is an inherent limitation of the compass system. However, we are using this system to understand how a specific voter is going to vote, and a voter at the origin is going to vote the same way whether they are an ``averages to zero'' voter or a ``center of the slider'' voter, so this nuance can safely be ignored. This fact that we are only interested in modeling voting habits allows for another important simplification. In reality, an individual voter may hold strong opinions on all axes, but think that one issue is more important that the others, and therefore vote differently than this model would predict. This problem could be solved by adding individualized weighting to each issue, however that would break the visual correlation between a Voter's position in the coordinate system and their voting preference; since this is supposed to be a demonstrative tool, that correlation is important. Because of this, we assume that a Political Entity's placement is already reflective of their individual weighting of the issues. This way the weighting of each axis can be treated as equal, preserving the visual correlation between preference and voting. \\

%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\section{Performance}
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000





%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\section{Examples}
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000







%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\section{Conclusion}
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000





%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
\section{Glossary}
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000
%0000000000000000000000000000000000000000000000000000000000000000000000000000000000


\end{document}

























